<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.35 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-hoffman-dns-over-http" category="std">

  <front>
    <title abbrev="DNS in JSON">DNS Queries over HTTPS</title>

    <author initials="P." surname="Hoffman" fullname="Paul Hoffman">
      <organization>ICANN</organization>
      <address>
        <email>paul.hoffman@icann.org</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization></organization>
      <address>
        <email>hildjj@cursive.net</email>
      </address>
    </author>

    <date year="2016" month="September" day="13"/>

    <area>Internet</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes how to make DNS queries and get DNS responses over HTTPS. The main
driver for this document is to allow clients who want to send DNS queries over HTTP
transport to be able to do in a secure and interoperable fashion, regardless of the format
of the responses.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Over time, there have been many proposals for using HTTP and HTTPS as a substrate for DNS
queries and responses. To date, none of those proposals have made it beyond early
discussion, partially due to disagreement about what is the “best” method to do so. In
particular, there has been disagreement about what the best format for the responses
should be. Also, some early proposals have not followed best practices for using HTTP.</t>

<t>This document defines a specific protocol for sending DNS <xref target="RFC1035"/> queries and getting DNS
responses over HTTP <xref target="RFC7230"/> that is running over TLS <xref target="RFC5246"/>. Although there might
be a desire to run this protocol over an insecure transport such as bare HTTP, this document
only defines the protocol as HTTP over TLS.</t>

<t>This design focuses on DNS stub-to-resolver communication, but DNS resolver-to-authoritative
communication should work just as well.</t>

<t>A server that supports this protocol is called a “DNS API server” to differentiate it from
a “DNS server” (one that uses the regular DNS protocol). Similarly, a client supports this protocol
is called a “DNS API client”.</t>

<section anchor="use-cases" title="Use Cases">

<t>Earlier proposals for DNS over HTTP have had many different use cases. The primary use
case is an application that wants to avoid network path involvement with DNS. The protocol can
be implemented in the application such as a browser if the location of the DNS API server
can be configured, hard-coded, or discoverable such as through DHCP.</t>

<t>Another use case is an operating system that wants to help applications when the OS
detects broken DNS in its operations. The OS can still respond to calls such as
getaddrinfo() and gethostbyname() by using this protocol without the applications
needing to do anything.</t>

<t>A more recent use case is a small (“IoT”) device that already runs COAP <xref target="RFC7252"/> and
has a JSON <xref target="RFC7159"/> or CBOR <xref target="RFC7049"/> parser and wants to make DNS queries beyond what
are supported by the device’s operating system.</t>

<t>An eventual use case might be editing of DNS zones by end users, such as described in
<xref target="I-D.hildebrand-deth"/>. Such editing could easily be done using existing HTTP
semantics.</t>

<t>As HTTP/2 <xref target="RFC7540"/> becomes more widely deployed, this use case might become more important
because an HTTP/2 server might push DNS responses to a client that the HTTP/2 server expects
the client to look up.</t>

</section>
<section anchor="protocol-requirements" title="Protocol Requirements">

<t>The protocol described here bases its design on the following protocol requirements:</t>

<t><list style="symbols">
  <t>The protocol must use HTTP semantics the way that they are commonly used
in other protocols; there is nothing special about the DNS use case.</t>
  <t>The protocol must run over secure transport.</t>
  <t>The query format must be able to be flexible enough to express every normal
DNS query.</t>
  <t>The response must be able to be in different formats that can be described
by different documents.</t>
  <t>Both the query format and the response formats must be extensible.
In specific, a query must be able to contain one or more EDNS extensions,
including those not yet defined. Further, it must be easy to define different
response formats and to extend already-defined formats.</t>
</list></t>

<t>A non-requirement for this protocol is that is needs to work with DNS64 <xref target="RFC6147"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as
described in BCP 14, RFC 2119 <xref target="RFC2119"/>.</t>

</section>
<section anchor="queries" title="Queries">

<t>The DNS API client finds a DNS API server through the same mechanism as for a DNS resolver:
DHCPv4, DHCPv6, IPv6 RA, and configuration. The DNS API client then discovers the server’s
capabilities and URI temple using the mechanism described in <xref target="discovery"/>. The URI
templates used in this protocol MUST be “https:” or “coaps:” for the scheme.</t>

<t>To send a DNS query, the DNS API client prepares an HTTP GET request and sends it to the
URI it received from the discovery step. The query is encoded as a set of name/value
components using the HTTP “?name=value” syntax, with an “&amp;” character between each pair.
Names and values are defined in <xref target="names_values"/>.</t>

<t>The HTTP-related requirements include:</t>

<t><list style="symbols">
  <t>The HTTP GET request MUST have no body.</t>
  <t>The HTTP GET request SHOULD be sent with an HTTP “Accept:” header to say what
type of content can be returned. If the request does not have an HTTP “Accept:” header, the
DNS API server might return a content type that the DNS API client does not understand.</t>
  <t>The HTTP GET request SHOULD use If-None-Match headers if earlier responses to the same
query used HTTP ETag headers as described in <xref target="RFC7232"/>.</t>
</list></t>

<t>For example, assume that the server’s template for the query is:</t>

<figure><artwork><![CDATA[
   https://dnsserver.example.com/
]]></artwork></figure>

<t>A query for the A records for www.somecompany.com would be:</t>

<figure><artwork><![CDATA[
   https://dnsserver.example.com/?qn=www.somecompany.com&qt=1
]]></artwork></figure>

<t>The HTTP request might look like:</t>

<figure><artwork><![CDATA[
   GET /?qn=www.somecompany.com&qt=1 HTTP/1.1
   User-Agent: curl/7.16.3 libcurl/7.16.3
   Host: dnsserver.example.com
   Accept: application/dns+json
]]></artwork></figure>

<t>This document only defines the semantics of the HTTP GET command for normal DNS
queries and responses. Other verbs will be defined in the future.  Other verbs will likely
need different authorization semantics as well as different discoverability for the
template. For example, see <xref target="I-D.hildebrand-deth"/>.</t>

</section>
<section anchor="names_values" title="Query Names and Values">

<t>The following are the names and descriptions of values for DNS API queries. Every query
MUST have a “qn” component and a “qt” component; all other components are optional.
DNS header values and extensions that are not appropriate for queries are not
defined.</t>

<t>Note that a query can only include a single qn and a single qt component. Although it may
be tempting to include multiple qt components (such as a single query for A and AAAA
records), DNS implementations historically have not dealt consistently with these. If
there are future standards for queries for multiple names and types, new components for
those standards can be defined.</t>

<t><list style="hanging">
  <t hangText='qn:'>
  QNAME from RFC 1035</t>
  <t hangText='qt:'>
  QTYPE from RFC 1035</t>
  <t hangText='qc:'>
  QCLASS from RFC 1035 – if omitted, server assumes 1</t>
  <t hangText='id:'>
  ID from RFC 1035 – if omitted, there is no default value</t>
  <t hangText='opcode:'>
  Opcode from RFC 1035 –  if omitted, server assumes 0</t>
  <t hangText='rd:'>
  RD from RFC 1035 – if omitted, server assumes 1</t>
  <t hangText='cd:'>
  CD from RFC 4035 – if omitted, server assumes 0</t>
  <t hangText='do:'>
  DO from RFC 4035 – if omitted, server assumes 1</t>
</list></t>

<t>The following are EDNS0 <xref target="RFC6891"/> extensions. If an extension is omitted, the server
assumes that the extension was not given in the request.</t>

<t><list style="hanging">
  <t hangText='nsid:'>
  Request the server’s NSID, based on <xref target="RFC5001"/></t>
  <t hangText='dau:'>
  Specify the list of signing algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='dhu:'>
  Specify the list of hash algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='n3u:'>
  Specify the list of NSEC3 hash algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='ecs:'>
  Specify the client subnet, based on <xref target="RFC7871"/>.
The value is the bytes of the ECS option, starting with byte 4,
encoded in lowercase hexadecimal.</t>
  <t hangText='pad:'>
  Optional padding, used for the same purposes as described in <xref target="RFC7830"/>.</t>
</list></t>

<t>See <xref target="ianacons"/> for a registry for additional names for queries.</t>

</section>
<section anchor="discovery" title="Discovery">

<t>A DNS API client discovers the capabilities of the DNS API server using
<xref target="I-D.nottingham-json-home"/>. For queries, the link relation is TBD.</t>

<t>Note that the response to this discover might be multiple templates. In those templates,
some of the URI types might not be supported by the resolver; this is fine as long as at
least one type is.  For example, if a discovery query returns both https: and coaps: URI
templates, but the DNS API client can only generate https: queries, the other URI
templates are ignored.</t>

<t>If a DNS API client only has a DNS resolver address but no configuration for a DNS API
server, the client can still use the discovery query to see if that DNS resolver is acting
as a DNS API server. That is, some DNS resolvers will run both the DNS protocol on port 53
and the DNS API on a different port.</t>

<t>The discovery response may give hints that the DSN API server requires a form of HTTP
authorization. The configuration of that authorization is out of scope for the DNS API
protocol. TODO: Need to think about HTTP authorization mechanisms. This would allow user
tracking, but could also free resolvers from having to use IP address ranges for
filtering.  Several bad ideas are likely here, so let’s think about it early.</t>

<t>TODO: Need to think about how to get both an IP address and domain name for
the SNI for HTTPS. Some ideas might come from RFC 7858.</t>

</section>
</section>
<section anchor="responses" title="Responses">

<t>Different response formats will provide more or less information from a DNS
response. For example, one response type might include the information from the
DNS header bytes while another might omit it. The amount and type of information
that a response format gives is solely up to the format, and not defined in
this protocol.</t>

<t>At the time this is published, the response types are works in progress. The
know response types include:</t>

<t><list style="symbols">
  <t><xref target="I-D.hoffman-dns-in-json"/> describes a response type in JSON</t>
  <t><xref target="I-D.song-dns-wireformat-http"/> describes a response type in DNS wire format</t>
</list></t>

<t>In the HTTP responses, the HTTP cache headers are set to shortest DNS TTL in the response.
The HTTP responses SHOULD set the HTTP ETag headers as described in <xref target="RFC7232"/>.</t>

</section>
<section anchor="ianacons" title="IANA Considerations">

<t>TODO: Create a new registry for option names for DNS queries.
This will be a simple registry for new option names, probably with
a designated expert.</t>

</section>
<section anchor="securitycons" title="Security Considerations">

<t>This protocol requires the use of TLS for communication. If a client does not enforce
authentication of the TLS server, the communication channel will be susceptible to many
security problems. See <xref target="RFC7435"/> for a fuller description of non-authenticated TLS.</t>

<t>TODO: Think about whether cross-origin resource sharing (CORS) applies to this
protocol and, if so, how to specify it.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>Early input to this document came from Mark Nottingham and
and Patrick McManus.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC1035' target='http://www.rfc-editor.org/info/rfc1035'>
<front>
<title>Domain names - implementation and specification</title>
<author initials='P.V.' surname='Mockapetris' fullname='P.V. Mockapetris'><organization /></author>
<date year='1987' month='November' />
<abstract><t>This RFC is the revised specification of the protocol and format used in the implementation of the Domain Name System.  It obsoletes RFC-883. This memo documents the details of the domain name client - server communication.</t></abstract>
</front>
<seriesInfo name='STD' value='13'/>
<seriesInfo name='RFC' value='1035'/>
<seriesInfo name='DOI' value='10.17487/RFC1035'/>
</reference>



<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7232' target='http://www.rfc-editor.org/info/rfc7232'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.</t></abstract>
</front>
<seriesInfo name='RFC' value='7232'/>
<seriesInfo name='DOI' value='10.17487/RFC7232'/>
</reference>



<reference anchor='I-D.nottingham-json-home'>
<front>
<title>Home Documents for HTTP APIs</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<date month='May' day='22' year='2016' />

<abstract><t>This document proposes a "home document" format for non-browser HTTP clients.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-nottingham-json-home-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-nottingham-json-home-04.txt' />
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC5001' target='http://www.rfc-editor.org/info/rfc5001'>
<front>
<title>DNS Name Server Identifier (NSID) Option</title>
<author initials='R.' surname='Austein' fullname='R. Austein'><organization /></author>
<date year='2007' month='August' />
<abstract><t>With the increased use of DNS anycast, load balancing, and other mechanisms allowing more than one DNS name server to share a single IP address, it is sometimes difficult to tell which of a pool of name servers has answered a particular query.  While existing ad-hoc mechanisms allow an operator to send follow-up queries when it is necessary to debug such a configuration, the only completely reliable way to obtain the identity of the name server that responded is to have the name server include this information in the response itself. This note defines a protocol extension to support this functionality.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5001'/>
<seriesInfo name='DOI' value='10.17487/RFC5001'/>
</reference>



<reference  anchor='RFC6147' target='http://www.rfc-editor.org/info/rfc6147'>
<front>
<title>DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</title>
<author initials='M.' surname='Bagnulo' fullname='M. Bagnulo'><organization /></author>
<author initials='A.' surname='Sullivan' fullname='A. Sullivan'><organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'><organization /></author>
<author initials='I.' surname='van Beijnum' fullname='I. van Beijnum'><organization /></author>
<date year='2011' month='April' />
<abstract><t>DNS64 is a mechanism for synthesizing AAAA records from A records. DNS64 is used with an IPv6/IPv4 translator to enable client-server communication between an IPv6-only client and an IPv4-only server, without requiring any changes to either the IPv6 or the IPv4 node, for the class of applications that work through NATs.  This document specifies DNS64, and provides suggestions on how it should be deployed in conjunction with IPv6/IPv4 translators.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6147'/>
<seriesInfo name='DOI' value='10.17487/RFC6147'/>
</reference>



<reference  anchor='RFC6891' target='http://www.rfc-editor.org/info/rfc6891'>
<front>
<title>Extension Mechanisms for DNS (EDNS(0))</title>
<author initials='J.' surname='Damas' fullname='J. Damas'><organization /></author>
<author initials='M.' surname='Graff' fullname='M. Graff'><organization /></author>
<author initials='P.' surname='Vixie' fullname='P. Vixie'><organization /></author>
<date year='2013' month='April' />
<abstract><t>The Domain Name System's wire protocol includes a number of fixed fields whose range has been or soon will be exhausted and does not allow requestors to advertise their capabilities to responders.  This document describes backward-compatible mechanisms for allowing the protocol to grow.</t><t>This document updates the Extension Mechanisms for DNS (EDNS(0)) specification (and obsoletes RFC 2671) based on feedback from deployment experience in several implementations.  It also obsoletes RFC 2673 (&quot;Binary Labels in the Domain Name System&quot;) and adds considerations on the use of extended labels in the DNS.</t></abstract>
</front>
<seriesInfo name='STD' value='75'/>
<seriesInfo name='RFC' value='6891'/>
<seriesInfo name='DOI' value='10.17487/RFC6891'/>
</reference>



<reference  anchor='RFC6975' target='http://www.rfc-editor.org/info/rfc6975'>
<front>
<title>Signaling Cryptographic Algorithm Understanding in DNS Security Extensions (DNSSEC)</title>
<author initials='S.' surname='Crocker' fullname='S. Crocker'><organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'><organization /></author>
<date year='2013' month='July' />
<abstract><t>The DNS Security Extensions (DNSSEC) were developed to provide origin authentication and integrity protection for DNS data by using digital signatures.  These digital signatures can be generated using different algorithms.  This document specifies a way for validating end-system resolvers to signal to a server which digital signature and hash algorithms they support.  The extensions allow the signaling of new algorithm uptake in client code to allow zone administrators to know when it is possible to complete an algorithm rollover in a DNSSEC-signed zone.</t></abstract>
</front>
<seriesInfo name='RFC' value='6975'/>
<seriesInfo name='DOI' value='10.17487/RFC6975'/>
</reference>



<reference  anchor='RFC7049' target='http://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
<abstract><t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract>
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>



<reference  anchor='RFC7159' target='http://www.rfc-editor.org/info/rfc7159'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2014' month='March' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='RFC' value='7159'/>
<seriesInfo name='DOI' value='10.17487/RFC7159'/>
</reference>



<reference  anchor='RFC7252' target='http://www.rfc-editor.org/info/rfc7252'>
<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t><t>CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract>
</front>
<seriesInfo name='RFC' value='7252'/>
<seriesInfo name='DOI' value='10.17487/RFC7252'/>
</reference>



<reference  anchor='RFC7435' target='http://www.rfc-editor.org/info/rfc7435'>
<front>
<title>Opportunistic Security: Some Protection Most of the Time</title>
<author initials='V.' surname='Dukhovni' fullname='V. Dukhovni'><organization /></author>
<date year='2014' month='December' />
<abstract><t>This document defines the concept &quot;Opportunistic Security&quot; in the context of communications protocols.  Protocol designs based on Opportunistic Security use encryption even when authentication is not available, and use authentication when possible, thereby removing barriers to the widespread use of encryption on the Internet.</t></abstract>
</front>
<seriesInfo name='RFC' value='7435'/>
<seriesInfo name='DOI' value='10.17487/RFC7435'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor='RFC7830' target='http://www.rfc-editor.org/info/rfc7830'>
<front>
<title>The EDNS(0) Padding Option</title>
<author initials='A.' surname='Mayrhofer' fullname='A. Mayrhofer'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document specifies the EDNS(0) &quot;Padding&quot; option, which allows DNS clients and servers to pad request and response messages by a variable number of octets.</t></abstract>
</front>
<seriesInfo name='RFC' value='7830'/>
<seriesInfo name='DOI' value='10.17487/RFC7830'/>
</reference>



<reference  anchor='RFC7871' target='http://www.rfc-editor.org/info/rfc7871'>
<front>
<title>Client Subnet in DNS Queries</title>
<author initials='C.' surname='Contavalli' fullname='C. Contavalli'><organization /></author>
<author initials='W.' surname='van der Gaast' fullname='W. van der Gaast'><organization /></author>
<author initials='D.' surname='Lawrence' fullname='D. Lawrence'><organization /></author>
<author initials='W.' surname='Kumari' fullname='W. Kumari'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes an Extension Mechanisms for DNS (EDNS0) option that is in active use to carry information about the network that originated a DNS query and the network for which the subsequent response can be cached.  Since it has some known operational and privacy shortcomings, a revision will be worked through the IETF for improvement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7871'/>
<seriesInfo name='DOI' value='10.17487/RFC7871'/>
</reference>



<reference anchor='I-D.hildebrand-deth'>
<front>
<title>DNS Editing Through HTTPS (DETH)</title>

<author initials='J' surname='Hildebrand' fullname='Joe Hildebrand'>
    <organization />
</author>

<author initials='P' surname='Hoffman' fullname='Paul E. Hoffman'>
    <organization />
</author>

<date month='March' day='21' year='2016' />

<abstract><t>There is a strong desire in many communities for service operators to be able to dynamically update DNS records in an easy-to-deploy, standardized method.  For example, operating SIP requires DNS records to be added and updated as the SIP service starts and is moved among different servers.  This document describes an HTTPS-based mechanism for service operators who are authorized by their DNS administrator to add, change, and delete DNS records.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hildebrand-deth-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hildebrand-deth-00.txt' />
</reference>



<reference anchor='I-D.hoffman-dns-in-json'>
<front>
<title>Representing DNS Messages in JSON</title>

<author initials='P' surname='Hoffman' fullname='Paul E. Hoffman'>
    <organization />
</author>

<date month='September' day='3' year='2016' />

<abstract><t>Some applications use DNS messages, or parts of DNS messages, as data.  For example, a system that captures DNS queries and responses might want to be able to easily search those without having to decode the messages each time.  Another example is a system that puts together DNS queries and responses from message parts.  This document describes a standardized format for DNS message data in JSON.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hoffman-dns-in-json-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hoffman-dns-in-json-07.txt' />
</reference>



<reference anchor='I-D.song-dns-wireformat-http'>
<front>
<title>DNS wire-format over HTTP</title>

<author initials='L' surname='Song' fullname='Linjian Song'>
    <organization />
</author>

<author initials='P' surname='Vixie' fullname='Paul A. Vixie'>
    <organization />
</author>

<author initials='S' surname='Kerr' fullname='Shane Kerr'>
    <organization />
</author>

<author initials='R' surname='Wan' fullname='Runxia Wan'>
    <organization />
</author>

<date month='June' day='21' year='2016' />

<abstract><t>This memo introduces a way to tunnel DNS data over HTTP.  This may be useful in any situation where DNS is not working properly, such as when there is middlebox misbehavior.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-song-dns-wireformat-http-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-song-dns-wireformat-http-04.txt' />
</reference>




    </references>



  </back>
</rfc>

