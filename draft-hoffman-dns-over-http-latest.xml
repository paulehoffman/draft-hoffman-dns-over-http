<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.35 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-hoffman-dns-over-http" category="std">

  <front>
    <title abbrev="DNS in JSON">DNS Queries over HTTPS</title>

    <author initials="P." surname="Hoffman" fullname="Paul Hoffman">
      <organization>ICANN</organization>
      <address>
        <email>paul.hoffman@icann.org</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization></organization>
      <address>
        <email>hildjj@cursive.net</email>
      </address>
    </author>

    <date year="2016" month="September" day="19"/>

    <area>Internet</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes how to make DNS queries and get DNS responses over HTTPS. The main
driver for this document is to allow clients who want to send DNS queries over HTTP
transport to be able to do in a secure and interoperable fashion, regardless of the format
of the responses.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Over time, there have been many proposals for using HTTP and HTTPS as a substrate for DNS
queries and responses. To date, none of those proposals have made it beyond early
discussion, partially due to disagreement about what is the “best” method to do so. In
particular, there has been disagreement about what the best format for the responses
should be. Also, some early proposals have not followed best practices for using HTTP.</t>

<t>This document defines a specific protocol for sending DNS <xref target="RFC1035"/> queries and getting DNS
responses over HTTP <xref target="RFC7230"/> that is running over TLS <xref target="RFC5246"/>. Although there might
be a desire to run this protocol over an insecure transport such as bare HTTP, this document
only defines the protocol as HTTP over TLS.</t>

<t>This design focuses on DNS stub-to-resolver communication, but DNS resolver-to-authoritative
communication should work just as well.</t>

<t>A server that supports this protocol is called a “DNS API server” to differentiate it from
a “DNS server” (one that uses the regular DNS protocol). Similarly, a client supports this protocol
is called a “DNS API client”.</t>

<section anchor="use-cases" title="Use Cases">

<t>Earlier proposals for DNS over HTTP have had many different use cases. The primary use
case is an application that wants to avoid network path involvement with DNS. The protocol can
be implemented in the application such as a browser if the location of the DNS API server
can be configured, hard-coded, or discoverable such as through DHCP.</t>

<t>Another use case is an operating system that wants to help applications when the OS
detects broken DNS in its operations. The OS can still respond to calls such as
getaddrinfo() and gethostbyname() by using this protocol without the applications
needing to do anything.</t>

<t>A more recent use case is a small (“IoT”) device that already runs COAP <xref target="RFC7252"/> and
has a JSON <xref target="RFC7159"/> or CBOR <xref target="RFC7049"/> parser and wants to make DNS queries beyond what
are supported by the device’s operating system.</t>

<t>An eventual use case might be editing of DNS zones by end users, such as described in
<xref target="I-D.hildebrand-deth"/>. Such editing could easily be done using existing HTTP
semantics.</t>

<t>As HTTP/2 <xref target="RFC7540"/> and QUIC <xref target="I-D.hamilton-early-deployment-quic"/> become
more widely deployed, this protocols might become more important because an
HTTP/2 or QUIC server might push DNS responses to a client that the HTTP/2 server
expects the client to look up.</t>

</section>
<section anchor="protocol-requirements" title="Protocol Requirements">

<t>The protocol described here bases its design on the following protocol requirements:</t>

<t><list style="symbols">
  <t>The protocol must use HTTP semantics the way that they are commonly used
in other protocols; there is nothing special about the DNS use case.</t>
  <t>The protocol must run over secure transport.</t>
  <t>The query format must be able to be flexible enough to express every normal
DNS query.</t>
  <t>The response must be able to be in different formats that can be described
by different documents.</t>
  <t>Both the query format and the response formats must be extensible.
In specific, a query must be able to contain one or more EDNS extensions,
including those not yet defined. Further, it must be easy to define different
response formats and to extend already-defined formats.</t>
</list></t>

<t>Non-requirements:</t>

<t><list style="symbols">
  <t>Supporting network-specific DNS64 <xref target="RFC6147"/></t>
  <t>Supporting other network-specific inferences from plaintext DNS queries</t>
</list></t>

</section>
<section anchor="terminology" title="Terminology">

<t>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as
described in BCP 14, RFC 2119 <xref target="RFC2119"/>.</t>

</section>
<section anchor="template" title="Template">

<t>The URI template (see <xref target="RFC6570"/>) for DNS API queries is:</t>

<figure><artwork><![CDATA[
{PREFIX}{QNAME}/{QTYPE}
]]></artwork></figure>

<t>The following variables are used to expand the URI template.</t>

<section anchor="prefix" title="PREFIX">

<t>“PREFIX” will be a URI fragment, such as “https://example.net/api/”.  The URI
protocol MUST be “https:” or “coaps:”.</t>

<t>The DNS API client discovers the PREFIX for the DNS API through the same
mechanism as for a DNS resolver: DHCPv4, DHCPv6, IPv6 RA, and configuration.
Specific PREFIX discovery mechanisms will be defined later, but imagine a new RA
option like that in <xref target="RFC6106"/> that gives a PREFIX.</t>

<t>If no PREFIX is configured as above, the client MAY query their existing DNS
server for API support by doing a URI query (see <xref target="RFC7553"/>) to the domain
“_dnsapi.invalid”.  If the DNS server knows about API support, the resulting
URI will be the PREFIX.</t>

<t>Note: there are several concerns to be worked out with respect to the PREFIX,
including how to bootstrap PREFIXes that contain domain names, and how to trust
TLS connections to PREFIXes that contain only IP addresses in a deployable way.</t>

</section>
<section anchor="qname" title="QNAME">

<t>The QNAME from <xref target="RFC1035"/>.</t>

<t>Note: An open issue exists with how to encode non-ASCII QNAMEs.  There are
several options:</t>

<t><list style="symbols">
  <t>Punycode all labels before sending</t>
  <t>Send the UTF8-encoded version after normalization, but before Punycoding</t>
  <t>Send generic UTF8-encoded labels, and make the server do normalization</t>
</list></t>

</section>
<section anchor="qtype" title="QTYPE">

<t>The numerical QTYPE from <xref target="RFC1035"/>.</t>

<t>Note: there are some people that want to use the string forms, such as “AAAA”,
perhaps in addition to the numerical form.  To be discussed.</t>

</section>
</section>
<section anchor="parameters" title="Additional Parameters">

<t>The following are the names and descriptions of parameters for DNS API queries.
All parameters are optional. DNS header values and extensions that are not
appropriate for queries are not defined.  Each parameter in the list below will
need to include a use case in a later version of this document; this list is a
first approximation of what may be needed.</t>

<t>Each of these parameters may be used in a query component of the URI sent
to the API, to modify the request.</t>

<t><list style="hanging">
  <t hangText='qc:'>
  QCLASS from <xref target="RFC1035"/> – if omitted, server assumes 1 (IN).  Might be needed
to support legacy DNS classes, or to access interesting new DNS capabilities.</t>
  <t hangText='id:'>
  ID from <xref target="RFC1035"/> – if omitted, there is no default value.  Could be used
to track responses.</t>
  <t hangText='opcode:'>
  Opcode from <xref target="RFC1035"/> –  if omitted, server assumes 0 (standard query)</t>
  <t hangText='rd:'>
  RD from <xref target="RFC1035"/> – if omitted, server assumes 1 (recursion desired)</t>
  <t hangText='cd:'>
  CD from <xref target="RFC4035"/> – if omitted, server assumes 1 (DNSSec checking
by the resolver disabled)</t>
  <t hangText='do:'>
  DO from <xref target="RFC4035"/> – if omitted, server assumes 1 (include RRSIG RDATA
in the response)</t>
</list></t>

<t>The following are EDNS0 <xref target="RFC6891"/> extensions. If an extension is omitted, the server
assumes that the extension was not given in the request.</t>

<t><list style="hanging">
  <t hangText='nsid:'>
  Request the server’s NSID, based on <xref target="RFC5001"/>.  Set to “1” to enable.</t>
  <t hangText='dau:'>
  Specify the list of signing algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='dhu:'>
  Specify the list of hash algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='n3u:'>
  Specify the list of NSEC3 hash algorithms understood, based on <xref target="RFC6975"/>.
The value is a list of integers separated by commas (with no spaces).</t>
  <t hangText='ecs:'>
  Specify the client subnet, based on <xref target="RFC7871"/>.
The value is the bytes of the ECS option, starting with byte 4,
encoded in lowercase hexadecimal.</t>
  <t hangText='pad:'>
  Optional padding, used for the same purposes as described in <xref target="RFC7830"/>.
This can be used to normalize the length of queries.</t>
</list></t>

<t>See <xref target="ianacons"/> for a registry for additional names for queries.</t>

</section>
<section anchor="queries" title="Queries">

<t>To send a DNS query, the DNS API client prepares an HTTP/CoAP GET request and
sends it to the URI it received from the discovery step.  Additional <xref target="parameters"/>
(if any) are specified.</t>

<t>The HTTP-related requirements include:</t>

<t><list style="symbols">
  <t>The HTTP GET request MUST have no body.</t>
  <t>The HTTP GET request SHOULD be sent with an HTTP “Accept:” header to say what
type of content can be returned. If the request does not have an HTTP “Accept:” header, the
DNS API server might return a content type that the DNS API client does not understand.</t>
  <t>The HTTP GET request SHOULD use If-None-Match headers if earlier responses to the same
query used HTTP ETag headers as described in <xref target="RFC7232"/>.</t>
</list></t>

<t>For example, assume that the server’s template for the query is:</t>

<figure><artwork><![CDATA[
   https://dnsserver.example.net/{QNAME}/{QTYPE}
]]></artwork></figure>

<t>A query for the A records for www.example.com would be:</t>

<figure><artwork><![CDATA[
   https://dnsserver.example.net/www.example.com/1
]]></artwork></figure>

<t>The HTTP request might look like:</t>

<figure><artwork><![CDATA[
   GET www.example.com/1 HTTP/1.1
   User-Agent: curl/7.16.3 libcurl/7.16.3
   Host: dnsserver.example.net
   Accept: application/dns+json
]]></artwork></figure>

<t>This document only defines the semantics of the HTTP/CoAP GET command for normal DNS
queries and responses. Other verbs will be defined in the future.  Other verbs will likely
need different authorization semantics as well as different discoverability for the
template. For example, see <xref target="I-D.hildebrand-deth"/>.</t>

</section>
<section anchor="discovery" title="Discovery">

<t><list style="numbers">
  <t>Look for configured URL.  If it exists, and does not use IPv4 or IPv6 as
the host name, look the host name up using the existing DNS infrastructure.
TODO: decide if this affects the applicability for this protocol, and discuss
the trade-offs of requiring valid certificates for IP addresses for configured
HTTPS URLs.</t>
  <t>Look for DHCP/DHCPv6/RA configured URL, and proceed as above.</t>
  <t>Look for existing DNS server IPv4/IPv6 address.  Construct a URL of the form
https://{IP}/</t>
</list></t>

<t>For any of the above,</t>

<t>TODO: decide whether the extra complexity of JSON-home is warranted vs. just
specifying the template parameters in this document and having a single template
URL be discoverable.</t>

<t>A DNS API client discovers the capabilities of the DNS API server using
<xref target="I-D.nottingham-json-home"/>. For queries, the link relation is TBD.</t>

<t>Note that the response to this discovery might be multiple templates. In those templates,
some of the URI types might not be supported by the resolver; this is fine as long as at
least one type is.  For example, if a discovery query returns both https: and coaps: URI
templates, but the DNS API client can only generate https: queries, the other URI
templates are ignored.</t>

<t>If a DNS API client only has a DNS resolver address but no configuration for a DNS API
server, the client can still use the discovery query to see if that DNS resolver is acting
as a DNS API server. That is, some DNS resolvers will run both the DNS protocol on port 53
and the DNS API on a different port.</t>

<t>The discovery response may give hints that the DNS API server requires a form of HTTP
authorization. The configuration of that authorization is out of scope for the DNS API
protocol. TODO: Need to think about HTTP authorization mechanisms. This would allow user
tracking, but could also free resolvers from having to use IP address ranges for
filtering.  Several bad ideas are likely here, so let’s think about it early.</t>

<t>TODO: Need to think about how to get both an IP address and domain name for
the SNI for HTTPS. Some ideas might come from RFC 7858.</t>

</section>
</section>
<section anchor="responses" title="Responses">

<t>Different response formats will provide more or less information from a DNS
response. For example, one response type might include the information from the
DNS header bytes while another might omit it. The amount and type of information
that a response format gives is solely up to the format, and not defined in
this protocol.</t>

<t>At the time this is published, the response types are works in progress. The
know response types include:</t>

<t><list style="symbols">
  <t><xref target="I-D.hoffman-dns-in-json"/> describes a response type in JSON</t>
  <t><xref target="I-D.song-dns-wireformat-http"/> describes a response type in DNS wire format</t>
</list></t>

<t>In the HTTP responses, the HTTP cache headers are set to shortest DNS TTL in the response.
The HTTP responses SHOULD set the HTTP ETag headers as described in <xref target="RFC7232"/>.</t>

</section>
<section anchor="ianacons" title="IANA Considerations">

<t>TODO: Create a new registry for option names for DNS queries.
This will be a simple registry for new option names, probably with
a designated expert.</t>

</section>
<section anchor="securitycons" title="Security Considerations">

<t>This protocol requires the use of TLS for communication. If a client does not enforce
authentication of the TLS server, the communication channel will be susceptible to many
security problems. See <xref target="RFC7435"/> for a fuller description of non-authenticated TLS.</t>

<t>TODO: Think about whether cross-origin resource sharing (CORS) applies to this
protocol and, if so, how to specify it.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>Early input to this document came from Mark Nottingham and
and Patrick McManus.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC1035' target='http://www.rfc-editor.org/info/rfc1035'>
<front>
<title>Domain names - implementation and specification</title>
<author initials='P.V.' surname='Mockapetris' fullname='P.V. Mockapetris'><organization /></author>
<date year='1987' month='November' />
<abstract><t>This RFC is the revised specification of the protocol and format used in the implementation of the Domain Name System.  It obsoletes RFC-883. This memo documents the details of the domain name client - server communication.</t></abstract>
</front>
<seriesInfo name='STD' value='13'/>
<seriesInfo name='RFC' value='1035'/>
<seriesInfo name='DOI' value='10.17487/RFC1035'/>
</reference>



<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC4035' target='http://www.rfc-editor.org/info/rfc4035'>
<front>
<title>Protocol Modifications for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'><organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'><organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'><organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'><organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'><organization /></author>
<date year='2005' month='March' />
<abstract><t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC).  The DNS Security Extensions are a collection of new resource records and protocol modifications that add data origin authentication and data integrity to the DNS.  This document describes the DNSSEC protocol modifications.  This document defines the concept of a signed zone, along with the requirements for serving and resolving by using DNSSEC.  These techniques allow a security-aware resolver to authenticate both DNS resource records and authoritative DNS error indications. </t><t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4035'/>
<seriesInfo name='DOI' value='10.17487/RFC4035'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor='RFC6570' target='http://www.rfc-editor.org/info/rfc6570'>
<front>
<title>URI Template</title>
<author initials='J.' surname='Gregorio' fullname='J. Gregorio'><organization /></author>
<author initials='R.' surname='Fielding' fullname='R. Fielding'><organization /></author>
<author initials='M.' surname='Hadley' fullname='M. Hadley'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='D.' surname='Orchard' fullname='D. Orchard'><organization /></author>
<date year='2012' month='March' />
<abstract><t>A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion. This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6570'/>
<seriesInfo name='DOI' value='10.17487/RFC6570'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7232' target='http://www.rfc-editor.org/info/rfc7232'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.</t></abstract>
</front>
<seriesInfo name='RFC' value='7232'/>
<seriesInfo name='DOI' value='10.17487/RFC7232'/>
</reference>



<reference  anchor='RFC7553' target='http://www.rfc-editor.org/info/rfc7553'>
<front>
<title>The Uniform Resource Identifier (URI) DNS Resource Record</title>
<author initials='P.' surname='Faltstrom' fullname='P. Faltstrom'><organization /></author>
<author initials='O.' surname='Kolkman' fullname='O. Kolkman'><organization /></author>
<date year='2015' month='June' />
<abstract><t>This document describes the already registered DNS resource record (RR) type, called the Uniform Resource Identifier (URI) RR, that is used for publishing mappings from hostnames to URIs.</t></abstract>
</front>
<seriesInfo name='RFC' value='7553'/>
<seriesInfo name='DOI' value='10.17487/RFC7553'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC5001' target='http://www.rfc-editor.org/info/rfc5001'>
<front>
<title>DNS Name Server Identifier (NSID) Option</title>
<author initials='R.' surname='Austein' fullname='R. Austein'><organization /></author>
<date year='2007' month='August' />
<abstract><t>With the increased use of DNS anycast, load balancing, and other mechanisms allowing more than one DNS name server to share a single IP address, it is sometimes difficult to tell which of a pool of name servers has answered a particular query.  While existing ad-hoc mechanisms allow an operator to send follow-up queries when it is necessary to debug such a configuration, the only completely reliable way to obtain the identity of the name server that responded is to have the name server include this information in the response itself. This note defines a protocol extension to support this functionality.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5001'/>
<seriesInfo name='DOI' value='10.17487/RFC5001'/>
</reference>



<reference  anchor='RFC6106' target='http://www.rfc-editor.org/info/rfc6106'>
<front>
<title>IPv6 Router Advertisement Options for DNS Configuration</title>
<author initials='J.' surname='Jeong' fullname='J. Jeong'><organization /></author>
<author initials='S.' surname='Park' fullname='S. Park'><organization /></author>
<author initials='L.' surname='Beloeil' fullname='L. Beloeil'><organization /></author>
<author initials='S.' surname='Madanapalli' fullname='S. Madanapalli'><organization /></author>
<date year='2010' month='November' />
<abstract><t>This document specifies IPv6 Router Advertisement options to allow IPv6 routers to advertise a list of DNS recursive server addresses and a DNS Search List to IPv6 hosts.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6106'/>
<seriesInfo name='DOI' value='10.17487/RFC6106'/>
</reference>



<reference  anchor='RFC6147' target='http://www.rfc-editor.org/info/rfc6147'>
<front>
<title>DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</title>
<author initials='M.' surname='Bagnulo' fullname='M. Bagnulo'><organization /></author>
<author initials='A.' surname='Sullivan' fullname='A. Sullivan'><organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'><organization /></author>
<author initials='I.' surname='van Beijnum' fullname='I. van Beijnum'><organization /></author>
<date year='2011' month='April' />
<abstract><t>DNS64 is a mechanism for synthesizing AAAA records from A records. DNS64 is used with an IPv6/IPv4 translator to enable client-server communication between an IPv6-only client and an IPv4-only server, without requiring any changes to either the IPv6 or the IPv4 node, for the class of applications that work through NATs.  This document specifies DNS64, and provides suggestions on how it should be deployed in conjunction with IPv6/IPv4 translators.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6147'/>
<seriesInfo name='DOI' value='10.17487/RFC6147'/>
</reference>



<reference  anchor='RFC6891' target='http://www.rfc-editor.org/info/rfc6891'>
<front>
<title>Extension Mechanisms for DNS (EDNS(0))</title>
<author initials='J.' surname='Damas' fullname='J. Damas'><organization /></author>
<author initials='M.' surname='Graff' fullname='M. Graff'><organization /></author>
<author initials='P.' surname='Vixie' fullname='P. Vixie'><organization /></author>
<date year='2013' month='April' />
<abstract><t>The Domain Name System's wire protocol includes a number of fixed fields whose range has been or soon will be exhausted and does not allow requestors to advertise their capabilities to responders.  This document describes backward-compatible mechanisms for allowing the protocol to grow.</t><t>This document updates the Extension Mechanisms for DNS (EDNS(0)) specification (and obsoletes RFC 2671) based on feedback from deployment experience in several implementations.  It also obsoletes RFC 2673 (&quot;Binary Labels in the Domain Name System&quot;) and adds considerations on the use of extended labels in the DNS.</t></abstract>
</front>
<seriesInfo name='STD' value='75'/>
<seriesInfo name='RFC' value='6891'/>
<seriesInfo name='DOI' value='10.17487/RFC6891'/>
</reference>



<reference  anchor='RFC6975' target='http://www.rfc-editor.org/info/rfc6975'>
<front>
<title>Signaling Cryptographic Algorithm Understanding in DNS Security Extensions (DNSSEC)</title>
<author initials='S.' surname='Crocker' fullname='S. Crocker'><organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'><organization /></author>
<date year='2013' month='July' />
<abstract><t>The DNS Security Extensions (DNSSEC) were developed to provide origin authentication and integrity protection for DNS data by using digital signatures.  These digital signatures can be generated using different algorithms.  This document specifies a way for validating end-system resolvers to signal to a server which digital signature and hash algorithms they support.  The extensions allow the signaling of new algorithm uptake in client code to allow zone administrators to know when it is possible to complete an algorithm rollover in a DNSSEC-signed zone.</t></abstract>
</front>
<seriesInfo name='RFC' value='6975'/>
<seriesInfo name='DOI' value='10.17487/RFC6975'/>
</reference>



<reference  anchor='RFC7049' target='http://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
<abstract><t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract>
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>



<reference  anchor='RFC7159' target='http://www.rfc-editor.org/info/rfc7159'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2014' month='March' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='RFC' value='7159'/>
<seriesInfo name='DOI' value='10.17487/RFC7159'/>
</reference>



<reference  anchor='RFC7252' target='http://www.rfc-editor.org/info/rfc7252'>
<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t><t>CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract>
</front>
<seriesInfo name='RFC' value='7252'/>
<seriesInfo name='DOI' value='10.17487/RFC7252'/>
</reference>



<reference  anchor='RFC7435' target='http://www.rfc-editor.org/info/rfc7435'>
<front>
<title>Opportunistic Security: Some Protection Most of the Time</title>
<author initials='V.' surname='Dukhovni' fullname='V. Dukhovni'><organization /></author>
<date year='2014' month='December' />
<abstract><t>This document defines the concept &quot;Opportunistic Security&quot; in the context of communications protocols.  Protocol designs based on Opportunistic Security use encryption even when authentication is not available, and use authentication when possible, thereby removing barriers to the widespread use of encryption on the Internet.</t></abstract>
</front>
<seriesInfo name='RFC' value='7435'/>
<seriesInfo name='DOI' value='10.17487/RFC7435'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor='RFC7830' target='http://www.rfc-editor.org/info/rfc7830'>
<front>
<title>The EDNS(0) Padding Option</title>
<author initials='A.' surname='Mayrhofer' fullname='A. Mayrhofer'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document specifies the EDNS(0) &quot;Padding&quot; option, which allows DNS clients and servers to pad request and response messages by a variable number of octets.</t></abstract>
</front>
<seriesInfo name='RFC' value='7830'/>
<seriesInfo name='DOI' value='10.17487/RFC7830'/>
</reference>



<reference  anchor='RFC7871' target='http://www.rfc-editor.org/info/rfc7871'>
<front>
<title>Client Subnet in DNS Queries</title>
<author initials='C.' surname='Contavalli' fullname='C. Contavalli'><organization /></author>
<author initials='W.' surname='van der Gaast' fullname='W. van der Gaast'><organization /></author>
<author initials='D.' surname='Lawrence' fullname='D. Lawrence'><organization /></author>
<author initials='W.' surname='Kumari' fullname='W. Kumari'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes an Extension Mechanisms for DNS (EDNS0) option that is in active use to carry information about the network that originated a DNS query and the network for which the subsequent response can be cached.  Since it has some known operational and privacy shortcomings, a revision will be worked through the IETF for improvement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7871'/>
<seriesInfo name='DOI' value='10.17487/RFC7871'/>
</reference>



<reference anchor='I-D.hamilton-early-deployment-quic'>
<front>
<title>QUIC: A UDP-Based Secure and Reliable Transport for HTTP/2</title>

<author initials='R' surname='Hamilton' fullname='Ryan Hamilton'>
    <organization />
</author>

<author initials='J' surname='Iyengar' fullname='Janardhan Iyengar'>
    <organization />
</author>

<author initials='I' surname='Swett' fullname='Ian Swett'>
    <organization />
</author>

<author initials='A' surname='Wilk' fullname='Alyssa Wilk'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP, designed from the ground up and optimized for HTTP/2 semantics.  While built with HTTP/2 as the primary application protocol, QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  QUIC provides multiplexing and flow control equivalent to HTTP/2, security equivalent to TLS, and connection semantics, reliability, and congestion control equivalent to TCP.  This draft documents the early deployment of the QUIC protocol prior to standardization.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hamilton-early-deployment-quic-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hamilton-early-deployment-quic-00.txt' />
</reference>



<reference anchor='I-D.hildebrand-deth'>
<front>
<title>DNS Editing Through HTTPS (DETH)</title>

<author initials='J' surname='Hildebrand' fullname='Joe Hildebrand'>
    <organization />
</author>

<author initials='P' surname='Hoffman' fullname='Paul Hoffman'>
    <organization />
</author>

<date month='March' day='21' year='2016' />

<abstract><t>There is a strong desire in many communities for service operators to be able to dynamically update DNS records in an easy-to-deploy, standardized method.  For example, operating SIP requires DNS records to be added and updated as the SIP service starts and is moved among different servers.  This document describes an HTTPS-based mechanism for service operators who are authorized by their DNS administrator to add, change, and delete DNS records.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hildebrand-deth-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hildebrand-deth-00.txt' />
</reference>



<reference anchor='I-D.hoffman-dns-in-json'>
<front>
<title>Representing DNS Messages in JSON</title>

<author initials='P' surname='Hoffman' fullname='Paul Hoffman'>
    <organization />
</author>

<date month='September' day='3' year='2016' />

<abstract><t>Some applications use DNS messages, or parts of DNS messages, as data.  For example, a system that captures DNS queries and responses might want to be able to easily search those without having to decode the messages each time.  Another example is a system that puts together DNS queries and responses from message parts.  This document describes a standardized format for DNS message data in JSON.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hoffman-dns-in-json-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hoffman-dns-in-json-07.txt' />
</reference>



<reference anchor='I-D.nottingham-json-home'>
<front>
<title>Home Documents for HTTP APIs</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<date month='May' day='22' year='2016' />

<abstract><t>This document proposes a "home document" format for non-browser HTTP clients.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-nottingham-json-home-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-nottingham-json-home-04.txt' />
</reference>



<reference anchor='I-D.song-dns-wireformat-http'>
<front>
<title>DNS wire-format over HTTP</title>

<author initials='L' surname='Song' fullname='Linjian Song'>
    <organization />
</author>

<author initials='P' surname='Vixie' fullname='Paul Vixie'>
    <organization />
</author>

<author initials='S' surname='Kerr' fullname='Shane Kerr'>
    <organization />
</author>

<author initials='R' surname='Wan' fullname='Runxia Wan'>
    <organization />
</author>

<date month='June' day='21' year='2016' />

<abstract><t>This memo introduces a way to tunnel DNS data over HTTP.  This may be useful in any situation where DNS is not working properly, such as when there is middlebox misbehavior.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-song-dns-wireformat-http-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-song-dns-wireformat-http-04.txt' />
</reference>




    </references>


<section anchor="previous-work-on-dns-over-http-or-in-other-formats" title="Previous Work on DNS over HTTP or in Other Formats">

<t>The following is a list of earlier work that related to DNS over HTTP or representing DNS
data in other formats. It is very likely incomplete, but will be expanded as this document
progresses.</t>

<t>The list includes links to the tools.ietf.org site (because these documents
are all expired) and web sites of software.</t>

<t><list style="symbols">
  <t>https://www.nlnetlabs.nl/projects/dnssec-trigger/</t>
  <t>https://tools.ietf.org/html/draft-mohan-dns-query-xml</t>
  <t>https://tools.ietf.org/html/draft-daley-dnsxml</t>
  <t>https://tools.ietf.org/html/draft-dulaunoy-dnsop-passive-dns-cof</t>
  <t>https://tools.ietf.org/html/draft-bortzmeyer-dns-json</t>
</list></t>

</section>


  </back>
</rfc>

